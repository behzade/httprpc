/* Code generated by {{.PackageName}}. DO NOT EDIT. */

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'

export interface ClientOptions { baseUrl: string; fetch?: typeof fetch }

export const __httprpc_checksum = {{quote .Checksum}}

export class {{.ClientName}} {
  private readonly baseUrl: string
  private readonly fetchImpl: typeof fetch

  constructor(opts: ClientOptions) {
    this.baseUrl = opts.baseUrl.replace(/\/$/, '')
    this.fetchImpl = opts.fetch ?? fetch
  }

  private async request<TReq, TRes>(method: HttpMethod, path: string, body?: TReq, headers?: Record<string, string>): Promise<TRes> {
    const url = this.baseUrl + path
    const res = await this.fetchImpl(url, {
      method,
      headers: {
        ...(body !== undefined ? { 'Content-Type': 'application/json' } : {}),
        ...(headers ?? {}),
      },
      body: body !== undefined ? JSON.stringify(body) : undefined,
    })
    if (!res.ok) {
      const text = await res.text().catch(() => '')
      throw new Error(text || res.statusText)
    }
    if (res.status === 204) return undefined as unknown as TRes
    return (await res.json()) as TRes
  }

{{- range .Endpoints}}
{{- if .HasBody}}
  async {{.MethodName}}(req: {{.ReqType}}): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>({{quote .Method}}, {{quote .Path}}, req, { 'Accept': {{quote .Produces}}, 'Content-Type': {{quote .Consumes}} })
  }

{{- else}}
  async {{.MethodName}}(): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>({{quote .Method}}, {{quote .Path}}, undefined, { 'Accept': {{quote .Produces}} })
  }

{{- end}}
{{- end}}
}

{{- range .TypeDefs}}
{{.}}

{{- end}}
