/* Code generated by {{.PackageName}}. DO NOT EDIT. */

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'

export interface ClientOptions { baseUrl: string; fetch?: typeof fetch }

export class {{.ClientName}} {
  private readonly baseUrl: string
  private readonly fetchImpl: typeof fetch

  constructor(opts: ClientOptions) {
    this.baseUrl = opts.baseUrl.replace(/\/$/, '')
    this.fetchImpl = opts.fetch ?? fetch
  }

  private buildURL(path: string, query?: unknown): string {
    if (!query) return this.baseUrl + path

    if (query instanceof URLSearchParams) {
      const qs = query.toString()
      return this.baseUrl + path + (qs ? `?${qs}` : '')
    }
    if (typeof query !== 'object') return this.baseUrl + path

    const params = new URLSearchParams()
    for (const [key, value] of Object.entries(query)) {
      if (value === undefined || value === null) continue
      if (Array.isArray(value)) {
        for (const v of value) {
          if (v === undefined || v === null) continue
          params.append(key, String(v))
        }
        continue
      }
      params.set(key, String(value))
    }
    const qs = params.toString()
    return this.baseUrl + path + (qs ? `?${qs}` : '')
  }

  private async request<TReq, TRes>(method: HttpMethod, path: string, body?: TReq, headers?: Record<string, string>, query?: unknown): Promise<TRes> {
    const url = this.buildURL(path, query)
    const res = await this.fetchImpl(url, {
      method,
      headers: {
        ...(body !== undefined ? { 'Content-Type': 'application/json' } : {}),
        ...(headers ?? {}),
      },
      body: body !== undefined ? JSON.stringify(body) : undefined,
    })
    if (!res.ok) {
      const text = await res.text().catch(() => '')
      throw new Error(text || res.statusText)
    }
    if (res.status === 204) return undefined as unknown as TRes
    return (await res.json()) as TRes
  }

{{- range .Endpoints}}
{{- if .HasBody}}
  async {{.MethodName}}(req: {{.ReqType}}): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>({{quote .Method}}, {{quote .Path}}, req, { 'Accept': {{quote .Produces}}, 'Content-Type': {{quote .Consumes}} })
  }

{{- else if .HasParams}}
  async {{.MethodName}}(req?: {{.ReqType}}): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>({{quote .Method}}, {{quote .Path}}, undefined, { 'Accept': {{quote .Produces}} }, req)
  }

{{- else}}
  async {{.MethodName}}(): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>({{quote .Method}}, {{quote .Path}}, undefined, { 'Accept': {{quote .Produces}} })
  }

{{- end}}
{{- end}}
}

{{- range .TypeDefs}}
{{.}}

{{- end}}
