/* Code generated by {{.PackageName}}. DO NOT EDIT. */

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'

export interface ClientOptions { baseUrl: string; fetch?: typeof fetch }

export class {{.ClientName}} {
  private readonly baseUrl: string
  private readonly fetchImpl: typeof fetch

  constructor(opts: ClientOptions) {
    this.baseUrl = opts.baseUrl.replace(/\/$/, '')
    this.fetchImpl = opts.fetch ?? fetch
  }

  private buildURL(path: string, query?: unknown, params?: Record<string, unknown>): string {
    if (params && Object.keys(params).length > 0) {
      for (const [key, value] of Object.entries(params)) {
        const encoded = encodeURIComponent(String(value ?? ''))
        path = path.replace(new RegExp(`:${key}(?=/|$)`, 'g'), encoded)
      }
    }
    if (!query) return this.baseUrl + path

    if (query instanceof URLSearchParams) {
      const qs = query.toString()
      return this.baseUrl + path + (qs ? `?${qs}` : '')
    }
    if (typeof query !== 'object') return this.baseUrl + path

    const searchParams = new URLSearchParams()
    for (const [key, value] of Object.entries(query)) {
      if (value === undefined || value === null) continue
      if (Array.isArray(value)) {
        for (const v of value) {
          if (v === undefined || v === null) continue
          searchParams.append(key, String(v))
        }
        continue
      }
      searchParams.set(key, String(value))
    }
    const qs = searchParams.toString()
    return this.baseUrl + path + (qs ? `?${qs}` : '')
  }

  private async request<TReq, TRes>(
    method: HttpMethod,
    path: string,
    body?: TReq,
    headers?: Record<string, string>,
    query?: unknown,
    params?: Record<string, unknown>,
  ): Promise<TRes> {
    const url = this.buildURL(path, query, params)
    const res = await this.fetchImpl(url, {
      method,
      headers: {
        ...(body !== undefined ? { 'Content-Type': 'application/json' } : {}),
        ...(headers ?? {}),
      },
      body: body !== undefined ? JSON.stringify(body) : undefined,
    })
    if (!res.ok) {
      const text = await res.text().catch(() => '')
      throw new Error(text || res.statusText)
    }
    if (res.status === 204) return undefined as unknown as TRes
    return (await res.json()) as TRes
  }

{{- range .Endpoints}}
{{- if .HasBody}}
  async {{.MethodName}}(
    req: {{.ReqType}},
{{- if .ParamSegments}}
    params: { {{- range $i, $seg := .ParamSegments}}{{if $i}}, {{end}}{{$seg}}: string | number{{- end}} },
{{- end}}
{{- if .HeaderFields}}
    headers{{if not .HeadersRequired}}?{{end}}: { {{- range $i, $field := .HeaderFields}}{{if $i}}, {{end}}{{$field.Key}}{{if $field.Optional}}?{{end}}: {{$field.Type}}{{- end}} },
{{- end}}
  ): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>(
      {{quote .Method}},
      {{quote .Path}},
      req,
{{- if .HeaderFields}}
      { 'Accept': {{quote .Produces}}, 'Content-Type': {{quote .Consumes}}, ...(headers ?? {}) },
{{- else}}
      { 'Accept': {{quote .Produces}}, 'Content-Type': {{quote .Consumes}} },
{{- end}}
{{- if .ParamSegments}}
      undefined,
      params,
{{- end}}
    )
  }

{{- else if .HasParams}}
  async {{.MethodName}}(
{{- if .ParamSegments}}
    params: { {{- range $i, $seg := .ParamSegments}}{{if $i}}, {{end}}{{$seg}}: string | number{{- end}} },
{{- end}}
{{- if .HeaderFields}}
    headers{{if not .HeadersRequired}}?{{end}}: { {{- range $i, $field := .HeaderFields}}{{if $i}}, {{end}}{{$field.Key}}{{if $field.Optional}}?{{end}}: {{$field.Type}}{{- end}} },
{{- end}}
    req?: {{.ReqType}},
  ): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>(
      {{quote .Method}},
      {{quote .Path}},
      undefined,
{{- if .HeaderFields}}
      { 'Accept': {{quote .Produces}}, ...(headers ?? {}) },
{{- else}}
      { 'Accept': {{quote .Produces}} },
{{- end}}
      req,
{{- if .ParamSegments}}
      params,
{{- end}}
    )
  }

{{- else}}
  async {{.MethodName}}(
{{- if .ParamSegments}}
    params: { {{- range $i, $seg := .ParamSegments}}{{if $i}}, {{end}}{{$seg}}: string | number{{- end}} },
{{- end}}
{{- if .HeaderFields}}
    headers{{if not .HeadersRequired}}?{{end}}: { {{- range $i, $field := .HeaderFields}}{{if $i}}, {{end}}{{$field.Key}}{{if $field.Optional}}?{{end}}: {{$field.Type}}{{- end}} },
{{- end}}
  ): Promise<{{.ResType}}> {
    return this.request<{{.ReqType}}, {{.ResType}}>(
      {{quote .Method}},
      {{quote .Path}},
      undefined,
{{- if .HeaderFields}}
      { 'Accept': {{quote .Produces}}, ...(headers ?? {}) },
{{- else}}
      { 'Accept': {{quote .Produces}} },
{{- end}}
{{- if .ParamSegments}}
      undefined,
      params,
{{- end}}
    )
  }

{{- end}}
{{- end}}
}

{{- range .TypeDefs}}
{{.}}

{{- end}}
